<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enzo&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-29T00:12:57.919Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Enzo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引及优化</title>
    <link href="http://example.com/2025/09/28/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2025/09/28/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/</id>
    <published>2025-09-28T11:05:33.000Z</published>
    <updated>2025-09-29T00:12:57.919Z</updated>
    
    <content type="html"><![CDATA[<p>在数据库系统中,索引是优化查询性能、保障服务稳定性的关键技术组件.尤其在数据量激增的现代应用场景下,缺乏有效的索引设计往往会导致查询性能急剧下降,进而影响整个应用的响应能力.深入理解索引的工作原理与实现机制,是每一位后端工程师和数据库管理员必须具备的核心技能.</p><span id="more"></span><h1 id="索引的本质与作用">1. 索引的本质与作用</h1><p>索引是一种用于高效检索数据的有序数据结构. 其核心价值在于通过预先排序的数据结构,将随机的I&#x2F;O转换为顺序的I&#x2F;O,并大幅减少查询过程中需要扫描的数据量,从而提升数据检索效率.</p><p>一个恰当的类比是书籍的目录：若无目录,查找特定内容需逐页翻阅（全表扫描）；而通过目录,则可快速定位到目标章节所在的精确页码.数据库索引正是扮演了“数据目录”的角色.</p><h1 id="索引的分类：聚簇索引与非聚簇索引">2. 索引的分类：聚簇索引与非聚簇索引</h1><p>根据索引与数据存储方式的关联,MySQL索引主要分为两大类：聚簇索引与非聚簇索引.</p><h2 id="聚簇索引">2.1. 聚簇索引</h2><p>定义：在InnoDB存储引擎中,主键索引即为聚簇索引.<br>核心特征：索引结构的叶子节点直接存储了完整的行数据.因此,表数据的物理存储顺序与聚簇索引的逻辑顺序保持一致.<br>关键机制：</p><ul><li>每个InnoDB表必须有且仅有一个聚簇索引.</li><li>聚簇索引的逻辑顺序直接影响了数据的物理存储顺序.这使得基于聚簇索引的范围查询（如WHERE id &gt; 1000）能够利用索引的有序性,避免全表扫描.</li><li>由于每个表只能有一个聚簇索引,因此在设计表结构时,应优先考虑将最常用作查询条件的列（如主键、外键）作为聚簇索引.</li></ul><p>若未显式定义主键,MySQL将选择一个唯一的非空索引替代；若不存在此类索引,则会自动生成一个隐藏的ROWID来构建聚簇索引.</p><p>最佳实践：推荐使用无业务含义的自增主键.这是因为自增主键的插入操作总是追加在数据页末尾,避免了因数据插入导致的页分裂与数据移动,性能开销最小.</p><h2 id="非聚簇索引">2.2. 非聚簇索引</h2><p>定义：所有非主键的索引（如普通索引、唯一索引、联合索引）均属于非聚簇索引.</p><p>核心特征：其叶子节点不存储行数据本身,而是存储对应记录的主键值.</p><p>查询流程：通过非聚簇索引进行查询时,数据库首先在索引树中查找目标主键值,然后根据该主键值回到聚簇索引中检索完整的行数据.此过程被称为 “回表”.</p><p>这种设计的优势在于避免了数据的冗余存储,保证了数据的一致性,但代价是可能引入额外的“回表”查询.</p><p>非聚簇索引的常见类型包括：</p><ul><li>普通索引：最基本的索引类型,仅用于加速查询,无唯一性约束.</li><li>唯一索引：保证索引列值的唯一性,兼具查询加速与数据完整性约束功能.</li><li>联合索引：基于多个列构建的索引.</li></ul><p>最左前缀原则：查询条件必须从联合索引的最左列开始匹配,否则索引将无法被有效利用.例如,索引(name, age, phone)对WHERE name &#x3D; ?有效,对WHERE name &#x3D; ? AND age &#x3D; ?也有效,但对WHERE age &#x3D; ?则无效.</p><p>全文索引：专为文本内容模糊匹配设计,但由于Elasticsearch等专业搜索引擎在此领域更具优势,其在MySQL中的使用已相对减少.</p><h1 id="底层数据结构：为何选择B-树？">3. 底层数据结构：为何选择B+树？</h1><p>MySQL InnoDB引擎默认采用B+Tree作为索引的底层实现.这一选择是针对数据库典型工作负载的深思熟虑之果.</p><h2 id="为何不选用Hash？">3.1. 为何不选用Hash？</h2><p>Hash索引虽能提供O(1)时间复杂度的等值查询,但其无法支持范围查询（如age &gt; 30）,而范围查询是业务场景中的高频操作,因此Hash索引不适用于作为通用的索引结构.</p><h2 id="B-树相较于B树的优势">3.2. B+树相较于B树的优势</h2><p>让我们通过一个定量分析来理解其设计精髓：<br>|特性|B树|B+树|<br>|非叶子节点|存储索引值及对应的行数据指针|仅存储索引值及指向子节点的指针|<br>|叶子节点|存储行数据指针|存储索引值及完整的行数据指针,并包含所有索引键|<br>|节点链接|叶子节点间无链接|叶子节点通过双向链表连接|</p><p>B+树的优势分析：<br>假设索引值占8B,行数据指针占6B,单个数据页大小为16KB.<br>在B树中,非叶子节点需存储索引值和数据指针,一个节点约存储 16KB &#x2F; (8B + 6B) ≈ 1170 个键值对,但其数据分布在整个树中.<br>在B+树中,非叶子节点仅存储索引值和子节点指针（共14B）,一页可存储约 16KB &#x2F; 14B ≈ 1170 个条目,这使得树的高度可以被有效控制.</p><p>B+树的核心优势在于：</p><ul><li>更低的树高：相同数据量下,B+树的深度更小,这意味着查询任意数据所需的磁盘I&#x2F;O次数更少,查询延迟更低.</li><li>稳定的查询性能：所有数据查询都必须抵达叶子节点,因此每次查询的路径长度相对稳定.</li><li>卓越的范围查询：叶子节点间的双向链表使范围查询异常高效,只需定位到范围的起始点,即可沿链表顺序扫描.</li></ul><h1 id="索引创建的最佳实践">4. 索引创建的最佳实践</h1><p>合理的索引设计是保障数据库性能的关键.以下是一些核心原则：</p><ul><li>控制索引数量：单表索引数量建议不超过5个.索引会引入额外的存储与维护成本,过多索引会显著降低数据写入（INSERT、UPDATE、DELETE）的速度.</li><li>限制联合索引字段数：联合索引的字段数同样建议不超过5个,以保持索引的简洁与高效.</li><li>审慎选择索引字段：<ul><li>适合建索引的字段：高频作为查询条件的字段、区分度高的列.</li><li>不适合建索引的字段：    <ul><li>频繁更新的字段（索引维护代价高）.</li><li>区分度极低的枚举字段（如gender,索引筛选效果差）.</li></ul></li></ul></li></ul><p>前缀索引优化：对于长文本字段（如varchar(255)）,可考虑仅对字段的前N个字符创建索引.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为username字段的前10个字符创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_username_prefix <span class="keyword">ON</span> users (username(<span class="number">10</span>));</span><br><span class="line">此举能在保证一定查询效率的同时,显著节约索引存储空间.N的取值需根据数据的前缀区分度来确定.</span><br></pre></td></tr></table></figure><h1 id="总结">5. 总结</h1><p>索引是数据库性能的基石.系统性地掌握其分类原理、B+树的底层工作机制以及科学的创建策略,对于构建高性能、可扩展的数据库应用至关重要.期望本文的阐述能帮助读者建立起对MySQL索引的深度认知,并在实践中做出最优的索引设计决策.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在数据库系统中,索引是优化查询性能、保障服务稳定性的关键技术组件.尤其在数据量激增的现代应用场景下,缺乏有效的索引设计往往会导致查询性能急剧下降,进而影响整个应用的响应能力.深入理解索引的工作原理与实现机制,是每一位后端工程师和数据库管理员必须具备的核心技能.&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>循环依赖问题</title>
    <link href="http://example.com/2025/09/22/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/22/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-22T12:41:58.000Z</published>
    <updated>2025-09-22T13:09:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring中,如果一个Bean尝试将自身引用注入到自身中或是多个微服务之间存在循环的引用,Spring会抛出<code>BeanCurrentlyInCreationException</code>异常,这被称为循环依赖问题.<br><img src="/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖问题"></p><span id="more"></span><h1 id="循环依赖问题">1. 循环依赖问题</h1><p>循环依赖问题通常发生在以下两种场景中:</p><ul><li><strong>单例Bean的构造器注入</strong>: 当两个或多个单例Bean通过构造器注入彼此时,就会发生循环依赖问题.</li><li><strong>原型Bean的循环依赖</strong>: 当两个或多个原型Bean之间存在循环依赖时,Spring会创建一个代理对象来解决循环依赖问题.</li></ul><p>在初始化A时需要注入B,要注入B就需要创建B实例再初始化B,而在初始B时需要注入A,此时A还没有创建完成就陷入死循环.</p><h2 id="解决方案">1.1. 解决方案</h2><h3 id="三级缓存-不存在AOP">1.1.1. 三级缓存 -&gt; 不存在AOP</h3><p>Spring通过三级缓存机制来解决单例Bean的循环依赖问题:</p><ul><li><strong>一级缓存</strong>: 存储完全初始化好的单例Bean.</li><li><strong>二级缓存</strong>: 存储正在初始化中的单例Bean.</li><li><strong>三级缓存</strong>: 存储原始的Bean定义,用于解决循环依赖问题.<br>创建A时,先生成原始A放入三级缓存,然后依赖B.没有B,所以再创建B,生成原始B放入二级缓存,然后依赖A,将三级缓存的A取到二级缓存,完成B的初始化,将B放入一级缓存.接着完成A的初始化,将A放入一级缓存.<br><img src="/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="三级缓存"><br>虽然过程中原始服务是半成品服务,但是Java是引用传递,拿到了相应服务的引用(也就是内存空间的地址)就行,后续都创建好了,拿到的服务就是完整的.</li></ul><h3 id="设计层面拆分业务逻辑-存在AOP">1.1.2. 设计层面拆分业务逻辑 -&gt; 存在AOP</h3><ul><li>引入中间服务类,避免A和B互相依赖,例如将A中需要依赖B的逻辑提取出来,放到一个中间服务类中,然后A和B都依赖这个中间服务类.</li><li>B可能只是用A的简单方法,不去依赖A,而是直接调用A的Mapper.</li></ul><h3 id="Lazy注解">1.1.3. Lazy注解</h3><p>使用<code>@Lazy</code>注解来延迟Bean的初始化,直到真正需要使用该Bean时才进行初始化.这可以避免在应用启动时就创建所有的Bean,从而减少循环依赖问题的发生.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Spring中,如果一个Bean尝试将自身引用注入到自身中或是多个微服务之间存在循环的引用,Spring会抛出&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt;异常,这被称为循环依赖问题.&lt;br&gt;&lt;img src=&quot;/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png&quot; alt=&quot;循环依赖问题&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="性能优化&#39;" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="三级缓存" scheme="http://example.com/tags/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>缓存穿透、缓存击穿和缓存雪崩问题</title>
    <link href="http://example.com/2025/09/19/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/19/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-19T12:12:56.000Z</published>
    <updated>2025-09-22T13:23:50.556Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式架构中,缓存是平衡性能与数据库压力的关键组件.然而,简单地引入 Redis 并不等于高枕无忧,错误的缓存策略反而会成为系统中最致命的单点.</p><p>缓存穿透、缓存击穿与缓存雪崩正是三种典型且破坏性极强的缓存失效场景,它们极易在高并发下导致数据库被打穿、服务雪崩式宕机.</p><p>本文将从技术原理层面深入剖析这三种问题的本质区别,并提供从代码到架构的多层级解决方案,包括但不限于：</p><ul><li>布隆过滤器（Bloom Filter）应对穿透</li><li>互斥锁（Mutex Lock）与逻辑过期化解击穿</li><li>密钥过期时间分散化与熔断降级策略预防雪崩<br>帮助你构建一个兼具高性能和高可用的健壮缓存系统.</li></ul><span id="more"></span><h1 id="缓存穿透">1. 缓存穿透</h1><h2 id="问题描述">1.1. 问题描述</h2><p>访问缓存中没有的数据,会去访问数据库获取.此时恶意访问者可以通过查询不存在的数据,来不断的访问数据库,导致数据库压力过大,甚至宕机.这种行为就好像穿透了缓存层直达数据库,所以叫缓存穿透.</p><h2 id="解决措施">1.2. 解决措施</h2><h3 id="布隆过滤器">1.2.1. 布隆过滤器</h3><p>布隆过滤器是一种空间效率高的概率型数据结构,用于判断一个元素是否存在于一个集合中.它的基本原理是将一个元素通过多个哈希函数映射到一个位数组上的多个位置,将这些位置的值设为1.当查询一个元素是否存在时,只需要判断这些位置的值是否都为1即可.如果有一个位置的值为0,则可以确定该元素不存在于集合中；如果所有位置的值都为1,则只能确定该元素可能存在于集合中.<br><img src="/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.png" alt="布隆过滤器原理"></p><p>布隆过滤器的优势在于它的空间效率高,只需要一个位数组和多个哈希函数即可实现.同时,它的查询时间复杂度为O(k),其中k为哈希函数的数量.</p><p>在缓存穿透问题中,我们可以使用布隆过滤器来缓存所有可能存在的key.当收到一个查询请求时,先使用布隆过滤器判断该key是否存在于缓存中.如果不存在,则直接返回空结果,避免继续访问数据库.如果存在,则继续访问缓存或数据库,根据实际情况返回结果.</p><h1 id="缓存击穿">2. 缓存击穿</h1><h2 id="问题描述-1">2.1. 问题描述</h2><p>缓存击穿是指<code>某个热点数据</code>在缓存中过期失效,造成大量并发请求同时到达数据库,导致数据库压力过大,甚至宕机.</p><h2 id="解决措施-1">2.2. 解决措施</h2><h3 id="互斥锁">2.2.1. 互斥锁</h3><p>互斥锁是一种用于保护共享资源的同步机制,确保同一时间只有一个线程能够访问共享资源.<br>当一个线程访问共享资源时,如果发现缓存中没有该数据,则会先尝试获取互斥锁.如果获取成功,则会去数据库查询数据,并将数据放入缓存中.如果获取失败,则会等待锁的释放,然后再次尝试获取互斥锁.</p><ul><li>Zookeeper 基于临时序号结点+监听机制</li><li>Redisson 基于Redlock算法的分布式锁,性能不如ZK,但在使用Redis的项目起码不用动整体架构</li></ul><h3 id="热点数据永不过期">2.2.2. 热点数据永不过期</h3><p>设置定时任务,定期更新热点数据的缓存.</p><h3 id="接口限流或降级">2.2.3. 接口限流或降级</h3><p>对热点数据的访问进行限流,防止大量并发请求同时到达数据库.当请求量超过一定阈值时,可以选择降级处理,直接返回缓存中的旧数据或默认数据.</p><h1 id="缓存雪崩">3. 缓存雪崩</h1><h2 id="问题描述-2">3.1. 问题描述</h2><p>缓存雪崩是指在缓存中<code>大量数据</code>同时过期失效,导致大量并发请求同时到达数据库,导致数据库压力过大,甚至宕机.</p><h2 id="解决措施-2">3.2. 解决措施</h2><h3 id="缓存过期时间分散化">3.2.1. 缓存过期时间分散化</h3><p>为了避免缓存雪崩,可以将缓存数据的过期时间设置为随机值,而不是固定值.这样可以确保缓存数据在不同时间过期,避免同时过期失效.</p><h3 id="热点数据永不过期-1">3.2.2. 热点数据永不过期</h3><p>设置定时任务,定期更新热点数据的缓存.</p><h3 id="分布式锁">3.2.3. 分布式锁</h3><p>使用分布式锁来保护缓存数据的更新操作,确保同一时间只有一个线程能够更新缓存数据.这样可以避免大量并发请求同时到达数据库.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分布式架构中,缓存是平衡性能与数据库压力的关键组件.然而,简单地引入 Redis 并不等于高枕无忧,错误的缓存策略反而会成为系统中最致命的单点.&lt;/p&gt;
&lt;p&gt;缓存穿透、缓存击穿与缓存雪崩正是三种典型且破坏性极强的缓存失效场景,它们极易在高并发下导致数据库被打穿、服务雪崩式宕机.&lt;/p&gt;
&lt;p&gt;本文将从技术原理层面深入剖析这三种问题的本质区别,并提供从代码到架构的多层级解决方案,包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;布隆过滤器（Bloom Filter）应对穿透&lt;/li&gt;
&lt;li&gt;互斥锁（Mutex Lock）与逻辑过期化解击穿&lt;/li&gt;
&lt;li&gt;密钥过期时间分散化与熔断降级策略预防雪崩&lt;br&gt;帮助你构建一个兼具高性能和高可用的健壮缓存系统.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="性能优化&#39;" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Canal+MQ同步流程</title>
    <link href="http://example.com/2025/09/14/Canal-MQ%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2025/09/14/Canal-MQ%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B/</id>
    <published>2025-09-14T00:23:40.000Z</published>
    <updated>2025-09-15T00:28:07.312Z</updated>
    
    <content type="html"><![CDATA[<p>在使用ES索引搜索时，我们需要同步ES和mysql数据库中的数据，常见的索引数据同步方案有两种：同步方式和异步方式。<br><img src="/Canal-MQ%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B.png" alt="同步流程"></p><span id="more"></span><h1 id="同步方式">1. 同步方式</h1><p>同步的方式很简单，即在原先mysql的业务上增加操作ES索引的代码，但是这种方法无法完成事务回滚，会出现信息不一致的情况，维护性差且代码更复杂了。</p><h1 id="异步方式">2. 异步方式</h1><p>异步的方法则是引入MQ，修改数据库后向MQ发送消息，消费者监听到MQ的消息后对ES索引作出操作来实现同步。这样的方法很好的实现了商品服务与ES的解耦合。但是在商品的业务层中依然要加入发送mq消息的代码，而canal完美解决了这个问题。</p><h1 id="Canal-MQ同步流程">3. Canal+MQ同步流程</h1><p>Canal会监听数据库中指定的表，这个被监听的表并非真正直接与商品对接的表，而是单独创造出来为了方便ES索引更改的包，他通常是原表的阉割版本，这样会让ES索引与数据库的同步更方便。一旦表被操作了，canal就会请求mysql读取binlog，然后向mq发出该表的操作日志。此时我们会在代码中写出的监听该队列的监听程序就会收到mq的更新日志并解析，解析过程中会去判断操作是否为删除，如果为删除，则执行批量删除操作，而如果是更改，则再进行更复杂的更改ES索引的操作的解析，解析完成后向es发送更新索引的请求，最终实现了mysql与ES索引的同步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用ES索引搜索时，我们需要同步ES和mysql数据库中的数据，常见的索引数据同步方案有两种：同步方式和异步方式。&lt;br&gt;&lt;img src=&quot;/Canal-MQ%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;同步流程&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
    <category term="Canal" scheme="http://example.com/tags/Canal/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java网关配置</title>
    <link href="http://example.com/2025/09/10/Java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2025/09/10/Java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/</id>
    <published>2025-09-10T12:32:36.000Z</published>
    <updated>2025-09-10T13:23:12.218Z</updated>
    
    <content type="html"><![CDATA[<p>前端请求网关根据请求路径路由到微服务,网关从nacos获取微服务实例地址将请求转发到具体的微服务实例上.<br>现在要根据需求使用Java在网关实现路由转发和用户身份认证的功能：</p><ul><li>根据请求Url路由到具体的微服务</li><li>校验用户的token,取出token中的用户信息</li><li>从nacos中取出服务实例进行负载均衡<br>所以使用java开发的网关,如</li><li>Spring Cloud Gateway:基于Spring的WebFlux技术,完全支持响应式编程,吞吐能力更强</li><li>NetFlix Zuul:早期实现,已淘汰<br><img src="/java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/%E7%BD%91%E5%85%B3%E9%80%BB%E8%BE%91.png" alt="网关架构图"></li></ul><span id="more"></span><h1 id="实现网关路由">1. 实现网关路由</h1><h2 id="添加依赖">1.1. 添加依赖</h2><p>在网关工程的<code>pom.xml</code>中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="新建启动类">1.2. 新建启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置路由">1.3. 配置路由</h2><p>在<code>application.yml</code>中配置路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">虚拟机IP:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">aaa</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://aaa-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/aaas/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">bbb</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://bbb-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/bbbs/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br></pre></td></tr></table></figure><p>路由规则routes包括四个属性,定义语法如下：</p><ul><li>id：路由的唯一标示</li><li>predicates：路由断言,<code>Predicates</code>是用于判断请求是否满足特定条件的组件</li><li>filters：路由过滤条件</li><li>uri：路由目标地址,lb:&#x2F;&#x2F;代表负载均衡,从注册中心获取目标微服务的实例列表,并且负载均衡选择一个访问</li></ul><p><code>predicates路由断言</code>的类型:<br><img src="/java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80.png" alt="路由断言"></p><h1 id="网关鉴权">2. 网关鉴权</h1><p>把身份校验的工作放到网关,确保只有经过授权的用户或设备才能访问特定的服务或资源：</p><ul><li>在网关和用户服务保存秘钥</li><li>在网关开发身份校验功能<br><img src="/java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83.png" alt="网关鉴权"><br>流程如下:</li><li>用户登录成功生成token并存储在前端</li><li>前端携带token访问网关</li><li>网关解析token中的用户信息,网关将请求转发到微服务,转发时携带用户信息</li><li>微服务从http头信息获取用户信息</li><li>微服务之间远程调用使用内部接口（无状态接口）</li></ul><h2 id="网关内置过滤器">2.1. 网关内置过滤器</h2><p>内置过滤器有很多，具体在工作中根据需求去使用<br><img src="/java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="内置过滤器"><br>例如使用StripPrefix过滤器的网关的路由配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure><p>StripPrefix&#x3D;1表示去除一级路径前缀,使用StripPrefix&#x3D;1后<br>请求：<a href="http://localhost:8080/product/items/page?pageNo=1&pageSize=1">http://localhost:8080/product/items/page?pageNo=1&amp;pageSize=1</a><br>路径到：<a href="http://localhost:8081/items/page?pageNo=1&pageSize=1(8081%E6%98%AF%E7%9B%AE%E6%A0%87%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AB%AF%E5%8F%A3)">http://localhost:8081/items/page?pageNo=1&amp;pageSize=1(8081是目标微服务的端口)</a></p><h2 id="自定义过滤器">2.2. 自定义过滤器</h2><p>无论是GatewayFilter还是GlobalFilter都支持自定义,只不过编码方式、使用方式略有差别</p><h3 id="自定义GlobalFilter">2.2.1. 自定义GlobalFilter</h3><p>全局过滤器不用在路由中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        log.info(<span class="string">&quot;打印全局过滤器&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">         <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line"><span class="comment">//        ServerHttpResponse response = exchange.getResponse();</span></span><br><span class="line"><span class="comment">//        response.setRawStatusCode(401);</span></span><br><span class="line"><span class="comment">//        return response.setComplete();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义GatewayFilter">2.2.2. 自定义GatewayFilter</h3><p>自定义GatewayFilter不是直接实现GatewayFilter,而是继承AbstractGatewayFilterFactory,<code>该类的名称一定要以GatewayFilterFactory为后缀</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstFilterGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;请求路径：&#123;&#125;&quot;</span>,request.getPath());</span><br><span class="line">                log.info(<span class="string">&quot;网关过滤器FirstFilterGatewayFilterFactory执行啦...&quot;</span>);</span><br><span class="line">                <span class="comment">//放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">                <span class="comment">//拦截 返回401状态码</span></span><br><span class="line">                <span class="comment">//exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span></span><br><span class="line">                <span class="comment">//return exchange.getResponse().setComplete();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置仅在product路由中有效的路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FirstFilter</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>配置在所有路由中都有效的路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">FirstFilter</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><h2 id="身份校验过滤器">2.3. 身份校验过滤器</h2><p>利用自定义<code>GlobalFilter</code>来完成身份校验,JWT工具类准备好,如:</p><ul><li>AuthProperties：配置身份校验需要拦截的路径,因为不是所有的路径都需要登录才能访问</li><li>JwtProperties：定义与JWT工具有关的属性,比如秘钥文件位置</li><li>SecurityConfig：工具的自动装配</li><li>JwtTool：JWT工具,其中包含了校验和解析token的功能</li><li>hmall.jks：秘钥文件</li></ul><h3 id="配置白名单">2.3.1. 配置白名单</h3><p>其中<code>AuthProperties</code>和<code>JwtProperties</code>所需的属性要在application.yaml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hm:</span><br><span class="line">  jwt:</span><br><span class="line">    location: classpath:hmall.jks # 秘钥地址</span><br><span class="line">    alias: hmall # 秘钥别名</span><br><span class="line">    password: hmall123 # 秘钥文件密码</span><br><span class="line">    tokenTTL: 30m # 登录有效期</span><br><span class="line">  auth:</span><br><span class="line">    excludePaths: # 无需身份校验的路径</span><br><span class="line">      - /search/**</span><br><span class="line">      - /users/login</span><br><span class="line">      - /items/**</span><br></pre></td></tr></table></figure><h3 id="定义过滤器">2.3.2. 定义过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AuthProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtTool jwtTool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthProperties authProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Request</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//请求路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath().toString();</span><br><span class="line">        <span class="comment">//白名单</span></span><br><span class="line">        List&lt;String&gt; excludePaths = authProperties.getExcludePaths();</span><br><span class="line">        <span class="comment">//判断当前请求路径是否是白名单,使用antPathMatcher进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (String excludePath : excludePaths) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> antPathMatcher.match(excludePath, path);</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取请求头的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果token为空则返回401错误</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果token不为空则校验token</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = jwtTool.parseToken(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//返回token无效的错误</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.如果有效，传递用户信息</span></span><br><span class="line">       exchange.getRequest().mutate().header(<span class="string">&quot;user-info&quot;</span>,userId.toString());</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 6.放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网关传递用户信息到微服务">2.4. 网关传递用户信息到微服务</h2><p><img src="/java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/%E4%BC%A0%E9%80%92%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.png" alt="传递用户信息"><br>利用SpringMVC的拦截器来实现登录用户信息获取,并存入ThreadLocal:</p><ul><li>改造网关过滤器,在获取用户信息后保存到请求头,转发到下游微服务</li><li>编写微服务拦截器,拦截请求获取用户信息,保存到ThreadLocal后放行</li></ul><h3 id="改造过滤器">2.4.1. 改造过滤器</h3><p>身份校验拦截器的处理逻辑，保存用户信息到请求头中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exchange.getRequest().mutate().header(<span class="string">&quot;user-info&quot;</span>,userId.toString());</span><br></pre></td></tr></table></figure><p>ThreadLocal工具返回从threadLocal中获取的userId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写拦截器">2.4.2. 编写拦截器</h3><p>编写拦截器,获取用户信息并保存到UserContext,然后放行<br>拦截器我们直接写在xxx-common中,并写好自动装配.这样微服务只需要引入xxx-common就可以直接具备拦截器功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.common.interceptor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 不为空，保存到ThreadLocal</span></span><br><span class="line">                UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置拦截器">2.4.3. 配置拦截器</h3><p>接着在xxx-common模块下编写SpringMVC的配置类,配置登录拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.common.config;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是,这个配置类默认是不会生效的,因为它所在的包是com.xxx.common.config,与其它微服务的扫描包不一致,无法被扫描到,因此无法生效。<br>基于SpringBoot的自动装配原理,我们要将其添加到<code>resources目录</code>下的<code>META-INF/spring.factories</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.hmall.common.config.MyBatisConfig,\</span><br><span class="line">  com.hmall.common.config.JsonConfig,\</span><br><span class="line">  com.hmall.common.config.MvcConfig</span><br></pre></td></tr></table></figure><h2 id="Feign接口传递用户">2.5. Feign接口传递用户</h2><p>有些业务是比较复杂的,请求到达微服务后还需要调用其它多个微服务,并没有传递用户信息</p><h3 id="方案1：OpenFeign拦截器">2.5.1. 方案1：OpenFeign拦截器</h3><p>微服务之间调用是基于OpenFeign来实现的,在进行OpenFeign调用时可以将用户信息放在http头中传递<br>借助实现Feign中提供的一个拦截器接口：feign.RequestInterceptor可以实现Feign拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignInterceptorConfig</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取登录用户</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">                <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">                template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案1就是在feign远程调用前在http头中添加用户信息，请求到达微服务由微服务拦截器解析出http头中的user-info放入ThreadLocal</p><h3 id="方案2-单独编写对应接口">2.5.2. 方案2: 单独编写对应接口</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端请求网关根据请求路径路由到微服务,网关从nacos获取微服务实例地址将请求转发到具体的微服务实例上.&lt;br&gt;现在要根据需求使用Java在网关实现路由转发和用户身份认证的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据请求Url路由到具体的微服务&lt;/li&gt;
&lt;li&gt;校验用户的token,取出token中的用户信息&lt;/li&gt;
&lt;li&gt;从nacos中取出服务实例进行负载均衡&lt;br&gt;所以使用java开发的网关,如&lt;/li&gt;
&lt;li&gt;Spring Cloud Gateway:基于Spring的WebFlux技术,完全支持响应式编程,吞吐能力更强&lt;/li&gt;
&lt;li&gt;NetFlix Zuul:早期实现,已淘汰&lt;br&gt;&lt;img src=&quot;/java%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE/%E7%BD%91%E5%85%B3%E9%80%BB%E8%BE%91.png&quot; alt=&quot;网关架构图&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="网关" scheme="http://example.com/tags/%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>OpenFeign配置</title>
    <link href="http://example.com/2025/09/10/OpenFeign%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2025/09/10/OpenFeign%E9%85%8D%E7%BD%AE/</id>
    <published>2025-09-10T12:01:40.000Z</published>
    <updated>2025-09-10T13:18:35.057Z</updated>
    
    <content type="html"><![CDATA[<p>OpenFeign技术可以让远程调用像本地方法调用一样简单,OpenFeign是一个声明式的HTTP客户端框架,它简化了编写 REST 客户端的过程</p><span id="more"></span><h1 id="添加依赖">1. 添加依赖</h1><p>在项目中添加OpenFeign的依赖,最好就在抽取的api工程中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="创建Feign客户端">2. 创建Feign客户端</h1><ul><li>在api工程定义一个接口来描述远程服务。</li><li>使用<code>@FeignClient</code>注解来标识远程调用接口,并指定服务名、接口路径.</li><li>对应服务工程引入api工程</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>对应服务工程的<code>Controller</code>实现该<code>Feign</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;xxx-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">XxxClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/xxxx/&#123;id&#125;&quot;)</span></span><br><span class="line">    Xxx <span class="title function_">getXxx</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/xxxx&quot;)</span></span><br><span class="line">    Xxx <span class="title function_">createXxx</span><span class="params">(<span class="meta">@RequestBody</span> Xxx xxx)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法.</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中的几个关键信息:</p><ul><li><code>@FeignClient(name=&quot;xxx-service&quot;)</code> ：声明服务名称</li><li><code>@FeignClient(path = &quot;/xxxx&quot;)</code>: 相当于XxxController类上的@RequestMapping(“&#x2F;xxxx”)指定的路径</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;XxxDTO&gt;</code> ：返回值类型</li></ul><h1 id="使用Feign客户端">3. 使用Feign客户端</h1><p>在调用者工程的实现类调用<code>XxxClient</code>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxxServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> XxxClient xxxClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用XxxCleint</span></span><br><span class="line">        List&lt;XxxDTO&gt; xxxDTOList = xxxClient.getXxx(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="启用OpenFeign">4. 启用OpenFeign</h1><p>在调用者工程的启动类添加<code>@EnableFeignClients</code>注解,启用OpenFeign</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.xxx.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxxApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(XxxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OKHttp">5. OKHttp</h1><p>Feign底层发起http请求,依赖于第三方的http客户端框架.常用的http客户端有：</p><ul><li>HttpURLConnection：默认实现,不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><h2 id="更换为OKHttp">5.1. 更换为OKHttp</h2><p>在调用者工程添加OKHttp的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在调用者工程的<code>application.yml</code>中添加配置开启Feign的连接池功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenFeign技术可以让远程调用像本地方法调用一样简单,OpenFeign是一个声明式的HTTP客户端框架,它简化了编写 REST 客户端的过程&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="OpenFeign" scheme="http://example.com/tags/OpenFeign/"/>
    
  </entry>
  
  <entry>
    <title>Nacos配置</title>
    <link href="http://example.com/2025/09/10/Nacos%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2025/09/10/Nacos%E9%85%8D%E7%BD%AE/</id>
    <published>2025-09-10T11:43:38.000Z</published>
    <updated>2025-09-10T12:01:11.483Z</updated>
    
    <content type="html"><![CDATA[<p>Nacos是国内产品,中文文档比较丰富,而且同时具备配置管理、服务注册与发现功能</p><span id="more"></span><h1 id="Docker配置">1. Docker配置</h1><h2 id="拉取Nacos镜像">1.1. 拉取Nacos镜像</h2><p><code>nacosxxx.tar</code>是nacos的镜像文件,nacos文件夹下是nacos配置文件<br>其中的<code>nacos/custom.env</code>文件中,有一个<code>MYSQL_SERVICE_HOST</code>也就是mysql地址,需要修改为虚拟机IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nacosxxx.tar</span><br></pre></td></tr></table></figure><h2 id="运行Nacos容器">1.2. 运行Nacos容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nacos \</span><br><span class="line">--env-file ./nacos/custom.env \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">-p 9848:9848 \</span><br><span class="line">-p 9849:9849 \</span><br><span class="line">--restart=always \</span><br><span class="line">nacos/nacos-server:vxxx</span><br></pre></td></tr></table></figure><h2 id="访问Nacos">1.3. 访问Nacos</h2><p>浏览器访问<code>http://虚拟机IP:8848/nacos/</code>,默认账号密码为<code>nacos/nacos</code></p><h1 id="服务注册">2. 服务注册</h1><h2 id="添加依赖">2.1. 添加依赖</h2><p>在父工程需要添加Spring Cloud及Spring Cloud Alibaba的版本约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring cloud--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   type=pom ,scope=import 表示继承 和 parent 作用一样             --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring cloud alibaba--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并定义nacos-client的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在服务工程的<code>pom.xml</code>中添加nacos-client的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置nacos">2.2. 配置nacos</h2><p>在服务工程的<code>application.yml</code>中添加nacos的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">xxxx-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">虚拟机IP:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><h2 id="启动服务">2.3. 启动服务</h2><p>显示以下日志为注册成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Success to connect to server [192.168.101.68:8848] on start up, connectionId ...</span><br></pre></td></tr></table></figure><h1 id="服务发现">3. 服务发现</h1><h2 id="添加依赖-1">3.1. 添加依赖</h2><p>由于还需要负载均衡,在服务工程的<code>pom.xml</code>中添加SpringCloud提供的LoadBalancer依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置nacos地址">3.2. 配置nacos地址</h2><p>在服务工程的<code>application.yml</code>中添加nacos的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">虚拟机IP:8848</span></span><br></pre></td></tr></table></figure><h2 id="调用其他服务">3.3. 调用其他服务</h2><p>任何一个微服务都可以调用别人,也可以被别人调用,即可以是调用者,也可以是提供者</p><h3 id="方法一">3.3.1. 方法一</h3><p>见<code>OpenFeign</code>篇,后续方法一个比一个麻烦</p><h3 id="方法二">3.3.2. 方法二</h3><p>调用者工程Config添加<code>RemoteCallConfig</code>类,使用<code>@LoadBalanced</code>注解标识<code>RestTemplate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者工程的Service使用<code>RestTemplate</code>调用提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// xxxx-service是提供者的服务名</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.exchange(<span class="string">&quot;http://xxxx-service/xxxx?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">                HttpMethod.GET,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;String&gt;() &#123;&#125;,</span><br><span class="line">                CollUtils.join(ids, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三">3.3.3. 方法三</h3><p>使用DiscoveryClient工具实现服务发现,SpringCloud已经帮我们自动装配,我们可以直接注入使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// xxxx-service是提供者的服务名</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;xxxx-service&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(instances)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.exchange(<span class="string">&quot;http://&quot;</span> + instance.getHost() + <span class="string">&quot;:&quot;</span> + instance.getPort() + <span class="string">&quot;/xxxx?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">                HttpMethod.GET,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;String&gt;() &#123;&#125;,</span><br><span class="line">                CollUtils.join(ids, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nacos是国内产品,中文文档比较丰富,而且同时具备配置管理、服务注册与发现功能&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ之面试题</title>
    <link href="http://example.com/2025/09/09/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2025/09/09/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2025-09-09T11:39:59.000Z</published>
    <updated>2025-09-10T13:23:52.275Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件消息队列MQ的一种,支持AMQP协议(SpringBoot支持AMQP协议).<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/RabbitMQ%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ架构"></p><span id="more"></span><h1 id="安装及启用">1. 安装及启用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=xxxx \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=xxxx \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> --restart=always \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>5672：MQ的通信端口<br>15672：管控台的端口</p><h1 id="同步调用与异步调用">2. 同步调用与异步调用</h1><h2 id="同步调用">2.1. 同步调用</h2><p>每一步调用者必须等待被调用方完全执行完毕并返回结果之后才能继续执行后续代码</p><h3 id="优缺点">2.1.1. 优缺点</h3><ul><li>优点:<ul><li>简单直观,代码易于理解和编写</li><li>易于调试,由于执行顺序明确,调试起来相对容易</li><li>对实时性要求较高的场景较好</li></ul></li><li>缺点:<ul><li>阻塞执行,如果一个操作需要很长时间来完成,那么整个程序会被阻塞,不能执行其他任务</li><li>资源浪费,在等待长时间操作完成时,CPU和其他资源可能会处于空闲状态 </li><li>级联失败问题,下游出错,上游也会出错</li><li>耦合度高,服务间直接调用</li><li>响应时长为几个服务处理时长的总和,性能和吞吐能力下降</li></ul></li></ul><h2 id="异步调用">2.2. 异步调用</h2><p>调用者发出调用后无需等待被调用方完成就可以继续执行其他任务</p><h3 id="优缺点-1">2.2.1. 优缺点</h3><ul><li>优点:<ul><li>提高效率,异步调用可以使得程序在等待某些耗时操作完成的同时执行其他任务,提高了整体的执行效率</li><li>资源利用率高,在等待耗时操作时,可以释放资源给其他任务使用,避免了资源浪费</li><li>更好的用户体验,在网络应用中,用户不必等待页面加载完成就能进行其他操作,提高了用户体验</li><li>需要处理耗时操作的场景较好</li><li>耦合度低,只与Broker耦合</li><li>高并发的请求由Broker承受,流量削峰,不会打到具体的服务</li></ul></li><li>缺点:<ul><li>复杂性增加,异步编程通常比同步编程更复杂,因为它涉及更多的控制结构和错误处理逻辑</li><li>调试困难,由于执行路径不是线性的,调试起来相对困难</li></ul></li></ul><h2 id="例子">2.3. 例子</h2><p>打电话预约服务</p><ul><li><code>同步调用</code>:<ul><li>预约餐桌</li><li>您稍等,我确认下是否可以预约</li><li>(五分钟后)您的预约已确认,请在指定时间到店</li><li>挂断</li></ul></li><li><code>异步调用</code>:<ul><li>预约餐桌</li><li>好的,稍后我会短信通知您</li><li>挂断</li></ul></li></ul><h1 id="主流MQ中间件">3. 主流MQ中间件</h1><ul><li>RabbitMQ</li><li>ActiveMQ</li><li>Kafka</li><li>RocketMQ</li><li>等</li></ul><h2 id="对比">3.1. 对比</h2><p><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%BB%E6%B5%81MQ%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94.png" alt="主流MQ中间件对比"></p><h2 id="选择">3.2. 选择</h2><ul><li>选择MQ中间件时,需要根据业务场景和需求进行选择</li><li>业务场景:<ul><li>实时性要求高:RabbitMQ</li><li>消息可靠性要求高:ActiveMQ</li><li>消息量要求高:Kafka</li><li>消息低延迟要求高:RocketMQ</li></ul></li><li>需求:<ul><li>功能完善:RabbitMQ、ActiveMQ、Kafka、RocketMQ</li><li>性能好:RabbitMQ、Kafka、RocketMQ</li><li>成本低:RabbitMQ、ActiveMQ、Kafka、RocketMQ</li></ul></li><li>最终: 公司用什么，我们用什么</li></ul><h1 id="RabbitMQ的组件角色">4. RabbitMQ的组件角色</h1><ul><li><code>Publisher 生产者</code>: 生产消息的应用</li><li><code>Consumer 消费者</code>: 消费消息的应用</li><li><code>Queue 队列</code>: 消息的缓冲区</li><li><code>Exchange 交换机</code>: 接收生产者发送的消息,根据路由键将消息路由到一个或多个队列</li><li><code>Binding 绑定</code>: 交换机和队列之间的关联关系,定义了路由规则</li><li><code>Routing Key 路由键</code>: 交换机根据路由键将消息路由到指定的队列</li><li><code>Virtual Host 虚拟主机</code>: 用于逻辑上隔离不同的消息队列,每个虚拟主机都有自己的交换机、队列和绑定关系</li></ul><h1 id="消息收发">5. 消息收发</h1><h2 id="实现步骤">5.1. 实现步骤</h2><p>(以下实现了解为主,AMQP的RabbitTemplate工具不需要编写这么复杂的逻辑)</p><ul><li>创建连接工厂</li><li>获取连接</li><li>创建通道</li><li>声明队列</li><li>(Publisher)发送消息,关闭通道和连接</li><li>(Consumer)异步订阅消息</li></ul><h2 id="Publisher生产消息">5.2. Publisher生产消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">// 创建通道</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;queue1&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, RabbitMQ!&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue1&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">    <span class="comment">// 关闭通道和连接</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Consumer消费消息">5.3. Consumer消费消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMessageTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">// 创建通道</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;queue1&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 异步订阅消息</span></span><br><span class="line">    channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息处理</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> consumerTag 消费者标签</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> envelope 信封</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> body 消息体</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringAMQP">6. SpringAMQP</h1><p>SpringBoot整合RabbitMQ的模板,相当于一个起步依赖<br><a href="https://spring.io/projects/spring-amqp#SpringAMQP%E5%AE%98%E7%BD%91">https://spring.io/projects/spring-amqp#SpringAMQP官网</a></p><h2 id="核心功能">6.1. 核心功能</h2><ul><li>RabbitTemplate: 用于发送和接收消息的核心类</li><li>自动声明队列、交换机及绑定关系</li><li>基于注解的监听器模式,异步接收消息</li></ul><h2 id="五种模式">6.2. 五种模式</h2><h3 id="Simple">6.2.1. Simple</h3><p>简单模式,一个生产者,一个消费者,一个队列<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/simple.png" alt="简单模式"></p><h3 id="Work-Queues">6.2.2. Work Queues</h3><p>工作队列模式,一个生产者,多个消费者,一个队列<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/workqueue.png" alt="工作队列模式"><br>多个消费者之间是竞争关系</p><h3 id="Fanout">6.2.3. Fanout</h3><p>广播模式,一个生产者,多个消费者,多个队列,消息发送到所有队列<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/fanout.png" alt="广播模式"><br>通过交换机,把消息路由到队列,实现群发</p><h3 id="Direct">6.2.4. Direct</h3><p>直接模式,一个生产者,多个消费者,多个队列,根据路由键路由到指定队列<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/direct.png" alt="直接模式"><br>与Fanout类似,但通过交换机,通过路由key的精确名称把消息路由到队列,实现群发</p><h3 id="Topics">6.2.5. Topics</h3><p>主题模式,一个生产者,多个消费者,多个队列,根据路由键路由到指定队列,支持通配符<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/topic.png" alt="主题模式"><br>与Direct类似,但通过交换机,通过路由key的<code>部分名称</code>把消息路由到队列,利用通配符识别</p><h2 id="消息转换器">6.3. 消息转换器</h2><p>消息转换器用于在Java对象和消息之间进行转换,常用的有:</p><ul><li><code>SimpleMessageConverter</code>: 默认的消息转换器,支持基本类型和字符串</li><li><code>Jackson2JsonMessageConverter</code>: 基于Jackson库的消息转换器,支持将Java对象转换为JSON格式的消息</li></ul><h3 id="默认消息转换器">6.3.1. 默认消息转换器</h3><p>默认的消息转换器,JDK序列化器,只能发送字符串和基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON消息转换器">6.3.2. JSON消息转换器</h3><p>配置JSON消息转换器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息可靠性">7. 消息可靠性</h1><h2 id="消息丢失的可能性">7.1. 消息丢失的可能性</h2><ul><li>消息未到达交换机</li><li>消息未正确路由到队列</li><li>MQ宕机,消息丢失</li><li>消费者接收消息,消费前宕机,消息丢失</li></ul><h2 id="确保消息不丢失的机制">7.2. 确保消息不丢失的机制</h2><h3 id="生产者确认机制">7.2.1. 生产者确认机制</h3><p><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6.png" alt="生产者确认机制"><br>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    publisher-confirm-type: correlated</span><br><span class="line">    publisher-returns: true</span><br><span class="line">    template:</span><br><span class="line">      mandatory: true</span><br></pre></td></tr></table></figure><ul><li><code>publish-confirm-type</code>：开启publisher-confirm<ul><li><code>correlated</code>: 异步回调,定义ConfirmCallback,MQ返回结果时会回调这个ConfirmCallback</li><li><code>simple</code>: 同步等待confirm结果,直到超时</li></ul></li><li><code>publisher-returns</code>：开启publisher-returns<ul><li><code>true</code>: 开启publisher-returns,同样是基于callback机制,不过是定义ReturnCallback</li><li><code>false</code>: 不开启publisher-returns</li></ul></li><li><code>template.mandatory</code>：开启mandatory<ul><li><code>true</code>: 调用ReturnCallback</li><li><code>false</code>: 直接丢弃消息</li></ul></li></ul><p>发送消息时指定ConfirmCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1.消息体</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.全局唯一的消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 3.添加callback</span></span><br><span class="line">    correlationData.getFuture().addCallback(</span><br><span class="line">        result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123;</span><br><span class="line">                <span class="comment">// 3.1.ack，消息成功</span></span><br><span class="line">                log.debug(<span class="string">&quot;消息发送成功, ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3.2.nack，消息失败</span></span><br><span class="line">                log.error(<span class="string">&quot;消息发送失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(), result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ex -&gt; log.error(<span class="string">&quot;消息发送异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(),ex.getMessage())</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;&quot;</span>, <span class="string">&quot;simple.queue&quot;</span>, message, correlationData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 休眠一会儿，等待ack回执</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义Return回调,每个RabbitTemplate只能配置一个ReturnCallback,因此需要在项目加载时配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 投递失败，记录日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                     replyCode, replyText, exchange, routingKey, message.toString());</span><br><span class="line">            <span class="comment">// 如果有业务需要，可以重发消息</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E9%80%BB%E8%BE%91.png" alt="生产者确认机制"></p><h3 id="持久化机制">7.2.2. 持久化机制</h3><p>durable默认就是true,交换机和队列默认都是持久化的</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化:在发送消息时，使用Message对象，并设置delivery-mode为持久化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProperties</span>();</span><br><span class="line">messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;hello, rabbitmq!&quot;</span>.getBytes(StandardCharsets.UTF_8), messageProperties);</span><br></pre></td></tr></table></figure><h3 id="消费者ack机制">7.2.3. 消费者ack机制</h3><p><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B6%88%E8%B4%B9%E8%80%85ack%E6%9C%BA%E5%88%B6.png" alt="消费者ack机制"><br>ack取值(默认auto):</p><ul><li><code>auto</code>: 自动ack,消息被消费后,自动返回ack</li><li><code>manual</code>: 手动ack,消费成功与否返回ack或<code>nack(让消息返回队列)</code></li><li><code>none</code>: 消费者收到消息直接返回ack给MQ,然后MQ直接删除消息,<code>消息可能会丢失</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;ack.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenAckQueue</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者1,收到消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        <span class="comment">// 手动ack</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 手动nack</span></span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto的本地重试配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        listener:</span><br><span class="line">        simple:</span><br><span class="line">            retry:</span><br><span class="line">                enabled: true # 开启本地重试</span><br><span class="line">                initial-interval: 1000 # 初始的失败等待时长为1秒</span><br><span class="line">                max-attempts: 3 # 最大重试次数</span><br><span class="line">                multiplier: 2.0 # 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span><br><span class="line">                stateless: true # true无状态；false有状态。如果业务中包含事务，这里改为false</span><br></pre></td></tr></table></figure><p>失败策略:</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，立即重新入队</li><li><code>TransactionRecoverer</code>：事务消息，失败后回滚事务</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将消息重新发布到指定的交换机</li></ul><p>RepublishMessageRecoverer机制<br>定义错误交换机、队列和绑定关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMsgConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue()).to(errorExchange()).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RepublishMessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.exchange&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听错误队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;error.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenErrorQueue</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;收到错误队列的消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息重复消费问题">8. 消息重复消费问题</h1><h2 id="问题描述">8.1. 问题描述</h2><p>消息重复消费是指同一条消息被消费者多次处理,可能导致数据不一致的问题,例如:</p><ul><li>数据库重复插入</li><li>重复发送邮件</li><li>重复更新缓存</li></ul><h2 id="问题原因">8.2. 问题原因</h2><p>本质是看消费的操作是否是幂等的</p><ul><li>消费者ack机制:如果消费者在处理消息时发生异常,没有返回ack,消息会被重新入队,导致重复消费</li><li>消费者重试机制:如果消费者在处理消息时发生异常,会触发重试机制,导致重复消费</li></ul><h2 id="解决办法">8.3. 解决办法</h2><p>利用数据库唯一约束和Redis</p><h3 id="方案一">8.3.1. 方案一</h3><p>生产者发送消息时携带唯一ID,消费者在处理消息前,先去Redis判断消息是否已经被处理,如果已经被处理,则直接丢弃消息</p><h3 id="方案二">8.3.2. 方案二</h3><p>生产者发送消息时携带唯一ID,消费者将ID用incr命令自增,如果返回值为1,则说明是第一次处理,如果返回值为0,则说明是重复处理</p><h1 id="消息顺序消费">9. 消息顺序消费</h1><h2 id="问题描述-1">9.1. 问题描述</h2><p>多个消费者消费同一个队列,如何保证消息顺序消费</p><h2 id="方案一-1">9.2. 方案一</h2><p>消费者指定线程消费数为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;order.queue&quot;, concurrency = &quot;1&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="方案二-1">9.3. 方案二</h2><p>MQ增加队列属性x-single-active-consumer为true<br><img src="/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9MQ%E5%B1%9E%E6%80%A7.png" alt="消息顺序消费"></p><h1 id="消息积压问题">10. 消息积压问题</h1><h2 id="问题原因-1">10.1. 问题原因</h2><p>生产者生产消息的速度远高于消费者消费消息的速度</p><h2 id="原因分析">10.2. 原因分析</h2><ul><li><code>设计问题</code>:生产者与消费者数量不匹配,重新设计</li><li><code>消费者出异常</code>:解决消费者代码</li><li><code>消费者宕机</code>:第一步：修复宕机的情况,第二步：临时开启多个消费者，来以倍速消费积压的消息。当积压的消息消费的差不多的情况，关闭临时消费者</li></ul><h2 id="采用惰性队列">10.3. 采用惰性队列</h2><p>惰性队列是指消息在内存中存储,当内存满时,将消息写入磁盘,以减少内存使用</p><h1 id="死信交换机">11. 死信交换机</h1><h2 id="产生情况">11.1. 产生情况</h2><ul><li>消费者使用basic.reject 或 basic.nack 声明消费失败，并且消息的requeue参数设置为false</li><li>消息设置了过期时间，或者消息存放的队列设置了过期时间，超过时间无人消费</li><li>要投递的队列消息满了，无法投递<br>这类消息为<code>死信</code>,传递给特定交换机,该交换机为<code>死信交换机</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ是基于Erlang语言开发的开源消息通信中间件消息队列MQ的一种,支持AMQP协议(SpringBoot支持AMQP协议).&lt;br&gt;&lt;img src=&quot;/RabbitMQ%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98/RabbitMQ%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;RabbitMQ架构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb的Bug之SpringBoot</title>
    <link href="http://example.com/2025/08/17/JavaWeb%E7%9A%84Bug%E4%B9%8BSpringBoot/"/>
    <id>http://example.com/2025/08/17/JavaWeb%E7%9A%84Bug%E4%B9%8BSpringBoot/</id>
    <published>2025-08-17T02:41:29.000Z</published>
    <updated>2025-08-17T02:50:48.546Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录SpringBoot的一些Bug和部分解决措施.</p><span id="more"></span><h1 id="未知异常-报错在Controller某个接口上">1. 未知异常 报错在Controller某个接口上</h1><h2 id="问题描述">1.1. 问题描述</h2><p>在使用SpringBoot开发时,某个Controller接口抛出未知异常,报错信息抛在接口地址上,但问题实际在Service层.<br>业务逻辑是上传pdf到OSS,然后再把OSS的地址填到DTO去调用大模型评测.</p><h2 id="问题排查">1.2. 问题排查</h2><p>表面错误是pdf上传失败,第二次上传成功,然后到后端调用大模型评测时,报未知异常.<br>一步步排查发现调用RedisTemplate时,错误在未指定泛型&lt;String, String&gt;.<br>该错误与报错信息没有任何关联,很难排查.</p><h2 id="解决方法">1.3. 解决方法</h2><p>指定RedisTemplate的泛型为&lt;String, String&gt;,问题解决.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录SpringBoot的一些Bug和部分解决措施.&lt;/p&gt;</summary>
    
    
    
    <category term="Bug" scheme="http://example.com/categories/Bug/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>常见大模型服务平台及其介绍</title>
    <link href="http://example.com/2025/08/16/%E5%B8%B8%E8%A7%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%85%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2025/08/16/%E5%B8%B8%E8%A7%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%85%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-08-16T12:17:43.000Z</published>
    <updated>2025-08-16T12:27:53.577Z</updated>
    
    <content type="html"><![CDATA[<p>常见的大模型服务平台有很多,以下是对一些主流平台的介绍,包括比较流行的百度千帆平台,OpenAI的ChatGPT,以及阿里云通义千问等.</p><span id="more"></span><h1 id="百度千帆平台">1. 百度千帆平台</h1><h2 id="介绍">1.1. 介绍</h2><p>支持百度自研的ERNIE（文心大模型） 系列（如文心一言）,同时兼容开源模型（如LLaMA、ChatGLM等）.<br>百度搜索内容时提示的ai功能就是文心一言提供的支持.</p><h2 id="功能">1.2. 功能</h2><ul><li><strong>模型选择</strong>: 提供多种模型选择,包括自研和开源模型.</li><li><strong>API接口</strong>: 提供RESTful API接口,方便集成到应用中</li><li><strong>多语言支持</strong>: 支持中文、英文等多种语言.</li><li><strong>自定义模型</strong>: 支持用户低参数微调自定义模型,满足特定需求,降低训练成本.</li></ul><h2 id="应用场景">1.3. 应用场景</h2><p>智能客服、内容生成、代码辅助、数据分析等</p><h1 id="阿里云通义千问">2. 阿里云通义千问</h1><h2 id="介绍-1">2.1. 介绍</h2><p>阿里云的大模型系列（如通义千问-7B&#x2F;14B），支持多模态（文本、图像）</p><h2 id="功能-1">2.2. 功能</h2><ul><li><strong>多模态支持</strong>: 支持文本、图像等多种输入形式</li><li><strong>API接口</strong>: 通过“灵积”平台提供RESTful API接口</li><li><strong>模型集成</strong>: 集成达摩院的预训练模型</li></ul><h2 id="应用场景-1">2.3. 应用场景</h2><p>电商、物流、娱乐等阿里生态场景</p><h1 id="腾讯混元大模型">3. 腾讯混元大模型</h1><h2 id="介绍-2">3.1. 介绍</h2><p>腾讯自研的千亿参数模型，支持文本、图像、视频生成</p><h2 id="应用场景-2">3.2. 应用场景</h2><p>与微信、腾讯云等产品深度结合，侧重社交和游戏场景</p><h1 id="华为盘古大模型">4. 华为盘古大模型</h1><h2 id="介绍-3">4.1. 介绍</h2><p>华为自研的大模型，支持文本、图像、视频生成,聚焦行业（矿山、气象、金融），强调“AI for Industries”</p><h2 id="应用场景-3">4.2. 应用场景</h2><p>结合昇腾芯片和MindSpore框架，优化端边云协同</p><h1 id="OpenAI-ChatGPT">5. OpenAI ChatGPT</h1><h2 id="介绍-4">5.1. 介绍</h2><p>OpenAI的ChatGPT是全球知名的大模型之一，提供强大的自然语言处理能力，支持文本生成、对话、问答等功能,但受限于国内的墙,国内并不流行</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的大模型服务平台有很多,以下是对一些主流平台的介绍,包括比较流行的百度千帆平台,OpenAI的ChatGPT,以及阿里云通义千问等.&lt;/p&gt;</summary>
    
    
    
    <category term="AI应用" scheme="http://example.com/categories/AI%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="大模型" scheme="http://example.com/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux终端常用命令</title>
    <link href="http://example.com/2025/08/01/Linux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2025/08/01/Linux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2025-07-31T16:34:52.000Z</published>
    <updated>2025-07-31T16:55:12.657Z</updated>
    
    <content type="html"><![CDATA[<p>Linux终端是与操作系统交互的重要工具，掌握常用命令可以提高工作效率。以下是一些常用的Linux终端命令。</p><span id="more"></span><h1 id="基本格式">1. 基本格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure><p>command ：命令名,相应功能的英文单词或单词的缩写<br>[-options] ：选项,特殊参数标识<br>parameter ：传给命令的参数,可以是 零个、一个 或者 多个</p><h1 id="快捷操作">2. 快捷操作</h1><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + C</td><td>终止当前命令</td></tr><tr><td>Ctrl + Z</td><td>暂停当前命令</td></tr><tr><td>Ctrl + D</td><td>退出终端</td></tr><tr><td>Ctrl + L</td><td>清屏</td></tr><tr><td>Ctrl + U</td><td>清空当前行</td></tr><tr><td>Ctrl + R</td><td>搜索历史命令</td></tr><tr><td>Ctrl + A</td><td>光标移动到行首</td></tr><tr><td>Ctrl + E</td><td>光标移动到行尾</td></tr></tbody></table><p><strong>自动补全</strong><br>输入文件或命令前几个字母后,按Tab键可以自动补全</p><h1 id="常用命令">3. 常用命令</h1><table><thead><tr><th>命令</th><th>说明</th><th>特殊参数</th></tr></thead><tbody><tr><td><strong>ls</strong></td><td>列出目录下的文件和子目录</td><td>-l 详细信息, -a 显示所有包括隐藏文件</td></tr><tr><td><strong>cd</strong></td><td>切换目录</td><td>find [目录路径] -name “文件名”</td></tr><tr><td><strong>pwd</strong></td><td>显示当前目录的路径</td><td></td></tr><tr><td><strong>clear</strong></td><td>清屏</td><td></td></tr><tr><td><strong>mkdir</strong></td><td>创建目录</td><td>-p 创建所有不存在的路径的目录</td></tr><tr><td><strong>touch</strong></td><td>创建文件</td><td>文件名</td></tr><tr><td><strong>rm</strong></td><td>删除文件</td><td>-f 强制删除, -r 递归删除目录</td></tr><tr><td><strong>cp</strong></td><td>复制文件</td><td>源文件 目标文件, -i 覆盖提示, -r 递归复制目录</td></tr><tr><td><strong>mv</strong></td><td>移动文件</td><td>源文件 目标文件, -i 覆盖提示</td></tr><tr><td><strong>cat</strong></td><td>显示文件内容</td><td>文件名, -b 显示行号</td></tr><tr><td><strong>more</strong></td><td>分页显示文件内容</td><td>文件名</td></tr><tr><td><strong>grep</strong></td><td>搜索文件内容</td><td>搜索内容 文件名</td></tr><tr><td><strong>find</strong></td><td>查找文件</td><td>查找路径 -name 文件名</td></tr><tr><td><strong>tar</strong></td><td>压缩文件</td><td>-zcvf 压缩文件名 源文件</td></tr><tr><td><strong>tar</strong></td><td>解压文件</td><td>-zxvf 压缩文件名</td></tr></tbody></table><h1 id="vi-vim-编辑器">4. vi&#x2F;vim 编辑器</h1><p>vi&#x2F;vim 是一个强大的文本编辑器，常用于编辑配置文件等。</p><table><thead><tr><th>模式</th><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>普通模式</td><td>输入 vi 文件名</td><td>查看文件内容</td></tr><tr><td>插入模式</td><td>普通模式下输入 i,a,o</td><td>从当前光标位置插入&#x2F;光标下一个字符&#x2F;行尾开始编辑文本</td></tr><tr><td>命令模式</td><td>普通模式下输入 :</td><td>输入命令,例如wq(保存并退出),q!(不保存并退出)</td></tr></tbody></table><h1 id="Docker命令">5. Docker命令</h1><h2 id="常用命令-1">5.1. 常用命令</h2><table><thead><tr><th>命令</th><th>说明</th><th>特殊参数</th></tr></thead><tbody><tr><td><strong>docker ps</strong></td><td>列出运行中的容器</td><td></td></tr><tr><td><strong>docker ps -a</strong></td><td>列出所有容器</td><td></td></tr><tr><td><strong>docker images</strong></td><td>列出所有镜像</td><td></td></tr><tr><td><strong>docker run</strong></td><td>运行容器</td><td>-d 后台运行, -p 端口映射, –name 容器名称</td></tr><tr><td><strong>docker exec</strong></td><td>在容器内执行命令</td><td>-it 交互式</td></tr><tr><td><strong>docker stop</strong></td><td>停止容器</td><td>容器ID或名称</td></tr><tr><td><strong>docker rm</strong></td><td>删除容器</td><td>容器ID或名称</td></tr><tr><td><strong>docker rmi</strong></td><td>删除镜像</td><td>镜像ID或名称, -f 强制删除</td></tr><tr><td><strong>docker build</strong></td><td>构建镜像</td><td>-t 镜像名称:标签 Dockerfile路径</td></tr><tr><td><strong>docker pull</strong></td><td>从仓库拉取镜像</td><td>镜像名称:标签</td></tr><tr><td><strong>docker push</strong></td><td>推送镜像到仓库</td><td>镜像名称:标签</td></tr><tr><td><strong>docker logs</strong></td><td>查看容器日志</td><td>容器ID或名称</td></tr><tr><td><strong>docker network ls</strong></td><td>列出网络</td><td></td></tr></tbody></table><h2 id="数据卷相关命令">5.2. 数据卷相关命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>docker volume create</strong></td><td>创建数据卷</td></tr><tr><td><strong>docker volume inspect</strong></td><td>查看数据卷信息</td></tr><tr><td><strong>docker volume rm</strong></td><td>删除数据卷</td></tr><tr><td><strong>docker volume prune</strong></td><td>删除未使用的数据卷</td></tr><tr><td><strong>docker volume ls</strong></td><td>列出所有数据卷</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux终端是与操作系统交互的重要工具，掌握常用命令可以提高工作效率。以下是一些常用的Linux终端命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="命令行" scheme="http://example.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>dependencyManagement和dependencies的区别</title>
    <link href="http://example.com/2025/07/22/dependencyManagement%E5%92%8Cdependencies%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2025/07/22/dependencyManagement%E5%92%8Cdependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-07-22T00:22:06.000Z</published>
    <updated>2025-07-22T01:04:14.421Z</updated>
    
    <content type="html"><![CDATA[<p>dependencyManagement和dependencies都是依赖相关的标签,但是不能互相替代</p><span id="more"></span><h1 id="dependencies">1. dependencies</h1><p>dependencies是用来声明项目的依赖,在项目中使用到的依赖都需要在dependencies中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dependencyManagement">2. dependencyManagement</h1><p>dependencyManagement是用来管理项目的依赖版本,在项目中使用到的依赖都需要在dependencyManagement中声明,一般写在父项目.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jjwt.version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">jjwt.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jjwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;dependencyManagement和dependencies都是依赖相关的标签,但是不能互相替代&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot原理</title>
    <link href="http://example.com/2025/07/20/SpringBoot%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2025/07/20/SpringBoot%E5%8E%9F%E7%90%86/</id>
    <published>2025-07-20T12:31:34.000Z</published>
    <updated>2025-07-21T00:24:00.056Z</updated>
    
    <content type="html"><![CDATA[<p>springboot原理篇，主要偏向于底层原理</p><ul><li>配置优先级</li><li>Bean管理</li><li>Springboot的底层原理</li></ul><span id="more"></span><h1 id="配置优先级">1. 配置优先级</h1><p>SpringBoot项目当中支持三类配置文件:</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml<br>优先级也是自高到底的顺序.(其中yml是主流配置文件,不推荐同时使用多种格式的配置文件)<br>除了配置文件以外,SpringBoot还支持Java属性配置(-Dkey&#x3D;value)和命令行参数(–key&#x3D;value)</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-Dserver.port=9000</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--server.port=10010</span></span><br></pre></td></tr></table></figure><p>五种配置方式的优先级:命令行参数 &gt;  系统属性参数 &gt; properties参数 &gt; yml参数 &gt; yaml参数</p><h1 id="Bean管理">2. Bean管理</h1><p>可以通过Spring当中提供的注解@Component以及它的三个衍生注解(@Controller、@Service、@Repository)来声明IOC容器中的bean对象.<br>及通过@Autowired注解来实现依赖注入DI.<br>以下设计两方面:</p><ul><li>bean的作用域配置</li><li>管理第三方的bean对象</li></ul><h2 id="Bean的作用域">2.1. Bean的作用域</h2><p>IOC容器当中,默认bean对象是单例的(只有一个实例对象)</p><table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>容器内同名称的bean只有一个实例(单例)(默认)</td></tr><tr><td>prototype</td><td>每次使用该bean时会创建新的实例(非单例)</td></tr><tr><td>request</td><td>每个请求范围内会创建新的实例(web环境中)</td></tr><tr><td>session</td><td>每个会话范围内会创建新的实例(web环境中)</td></tr><tr><td>application</td><td>每个应用范围内会创建新的实例(web环境中)</td></tr><tr><td>通过@Scope注解配置作用域,可以使用@Lazy注解来延迟初始化到第一次使用时.</td><td></td></tr></tbody></table><h2 id="第三方Bean">2.2. 第三方Bean</h2><p>引入第三方依赖提供的类无法使用@Component及其衍生注解来声明Bean,此时需使用@Bean注解来声明bean.<br>例子 在启动类中直接声明这个Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.utils.AliyunOSSOperator;</span><br><span class="line"><span class="keyword">import</span> com.itheima.utils.AliyunOSSProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TliasWebManagementApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TliasWebManagementApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliyunOSSOperator <span class="title function_">aliyunOSSOperator</span><span class="params">(AliyunOSSProperties ossProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliyunOSSOperator</span>(ossProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子 通过 @Configuration 注解声明一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.utils.AliyunOSSOperator;</span><br><span class="line"><span class="keyword">import</span> com.itheima.utils.AliyunOSSProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OSSConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliyunOSSOperator <span class="title function_">aliyunOSSOperator</span><span class="params">(AliyunOSSProperties ossProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliyunOSSOperator</span>(ossProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot原理">3. SpringBoot原理</h1><p>学习SpringBoot的原理就是来解析SpringBoot当中的起步依赖与自动配置的原理</p><h2 id="起步依赖">3.1. 起步依赖</h2><p>引入了 spring-boot-starter-web 之后,maven会通过依赖传递特性,将web开发所需的常见依赖都传递下来.(springboot-starter-web集成了web开发中常见的依赖:json、web、webmvc、tomcat等)<br><img src="/SpringBoot%E5%8E%9F%E7%90%86/%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96.png" alt="起步依赖"><br>所以,起步依赖的原理就是Maven的依赖传递.</p><h2 id="自动配置">3.2. 自动配置</h2><p>SpringBoot的自动配置就是当spring容器启动后,一些配置类、bean对象就自动存入到了IOC容器中,不需要我们手动去声明,从而简化了开发,省去了繁琐的配置操作</p><h3 id="实现方案">3.2.1. 实现方案</h3><p>导入com.example依赖却无法@Autowired注入,是因为SpringBoot项目中的@SpringBootApplication注解,虽然具有包扫描的作用,但是它只会扫描启动类所在的当前包以及子包,而当前包是com.it</p><h4 id="方案1-ComponentScan-组件扫描">3.2.1.1. 方案1 @ComponentScan 组件扫描</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima&quot;,&quot;com.example&quot;&#125;)</span> <span class="comment">//指定要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfigApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要引入大量的第三方的依赖,就需要在启动类上配置N多要扫描的包,这种方式会很繁琐,而且这种大面积的扫描性能也比较低.</p><h4 id="方案2-Import导入">3.2.1.2. 方案2 @Import导入</h4><h5 id="Import导入普通类">3.2.1.2.1. @Import导入普通类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(TokenParser.class)</span> <span class="comment">//导入的类会被Spring加载到IOC容器中</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfigApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Import导入配置类">3.2.1.2.2. @Import导入配置类</h5><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderGenerator <span class="title function_">headerGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(HeaderConfig.class)</span> <span class="comment">//导入配置类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Import导入ImportSelector接口实现类">3.2.1.2.3. @Import导入ImportSelector接口实现类</h5><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">//返回值字符串数组（数组中封装了全限定名称的类）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.example.HeaderConfig&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(MyImportSelector.class)</span> <span class="comment">//导入ImportSelector接口实现类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三方依赖自己指定bean对象和配置类提供的-EnableXxxxx注解">3.2.1.2.4. 第三方依赖自己指定bean对象和配置类提供的@EnableXxxxx注解</h5><p>比较常见的方案就是第三方依赖给我们提供一个注解,这个注解一般都以@EnableXxxx开头的注解,注解中封装的就是@Import注解.<br>第三方依赖提供的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span><span class="comment">//指定要导入哪些bean对象或配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHeaderConfig &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHeaderConfig</span>  <span class="comment">//使用第三方依赖提供的Enable开头的注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理分析">3.2.2. 原理分析</h3><h4 id="源码跟踪">3.2.2.1. 源码跟踪</h4><p>根据SpringBoot的自动配置原理,要从SpringBoot启动类上使用的核心注解@SpringBootApplication开始分析<br><img src="/SpringBoot%E5%8E%9F%E7%90%86/%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA1.png" alt="自动配置原理"><br>@Configuration表明SpringBoot启动类就是一个配置类<br>@Indexed用来加速应用启动的(不用关心)<br>@ComponentScan注解是用来扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类<br>@Import注解导入了实现ImportSelector接口的实现类AutoConfigurationImportSelector类(ImportSelector接口的实现类),AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法<br><img src="/SpringBoot%E5%8E%9F%E7%90%86/%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA2.png" alt="自动配置原理2"><br>selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合<br><img src="/SpringBoot%E5%8E%9F%E7%90%86/%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA3.png" alt="自动配置原理3"><br>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合<br><img src="/SpringBoot%E5%8E%9F%E7%90%86/%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA4.png" alt="自动配置原理4"><br>getCandidateConfigurations方法的功能：<br>获取所有基于 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中配置类的集合(配置类中定义了@Bean注解标识的方法)<br><img src="/SpringBoot%E5%8E%9F%E7%90%86/%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA5.png" alt="自动配置原理5"></p><p>自动配置的原理就是在配置类中定义一个@Bean标识的方法,而Spring会自动调用配置类中使用@Bean标识的方法,并把方法的返回值注册到IOC容器中.<br>当SpringBoot程序启动时,就会加载配置文件当中所定义的配置类,并将这些配置类信息(类的全限定名)封装到String类型的数组中,最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中,交给IOC容器管理.</p><h4 id="Conditional">3.2.2.2. @Conditional</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;springboot原理篇，主要偏向于底层原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置优先级&lt;/li&gt;
&lt;li&gt;Bean管理&lt;/li&gt;
&lt;li&gt;Springboot的底层原理&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>面向切面编程AOP</title>
    <link href="http://example.com/2025/07/20/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP/"/>
    <id>http://example.com/2025/07/20/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP/</id>
    <published>2025-07-20T12:10:57.000Z</published>
    <updated>2025-07-21T00:14:00.588Z</updated>
    
    <content type="html"><![CDATA[<p>AOP：Aspect Oriented Programming(面向切面编程、面向方面编程)</p><ul><li>减少重复代码：不需要在业务方法中定义大量的重复性的代码，只需要将重复性的代码抽取到AOP程序中即可。</li><li>代码无侵入：在基于AOP实现这些业务功能时，对原有的业务代码是没有任何侵入的，不需要修改任何的业务代码。</li><li>提高开发效率</li><li>维护方便</li></ul><span id="more"></span><h1 id="导入AOP依赖及入门代码实现">1. 导入AOP依赖及入门代码实现</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切面类用来记录方法执行时间的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//当前类为切面类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecordTimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.impl.DeptServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//记录方法执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录方法执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算方法执行耗时</span></span><br><span class="line">        log.info(<span class="string">&quot;方法执行耗时: &#123;&#125;毫秒&quot;</span>,end-begin);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;AOP：Aspect Oriented Programming(面向切面编程、面向方面编程)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少重复代码：不需要在业务方法中定义大量的重复性的代码，只需要将重复性的代码抽取到AOP程序中即可。&lt;/li&gt;
&lt;li&gt;代码无侵入：在基于AOP实现这些业务功能时，对原有的业务代码是没有任何侵入的，不需要修改任何的业务代码。&lt;/li&gt;
&lt;li&gt;提高开发效率&lt;/li&gt;
&lt;li&gt;维护方便&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Web登录校验之统一拦截技术</title>
    <link href="http://example.com/2025/07/17/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2025/07/17/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA%E6%8A%80%E6%9C%AF/</id>
    <published>2025-07-17T13:17:55.000Z</published>
    <updated>2025-07-20T12:03:43.514Z</updated>
    
    <content type="html"><![CDATA[<p>统一拦截技术有两种,Filter过滤器和Interceptor拦截器,用于统一拦截到所有的请求校验令牌的有效性.两种只需要实现一种即可.</p><span id="more"></span><h1 id="Filter过滤器">1. Filter过滤器</h1><p>Filter表示过滤器,是 JavaWeb三大组件(Servlet、Filter、Listener)之一,可以把对资源的请求拦截下来,从而实现一些特殊的功能,比如完成一些通用的操作:登录校验、统一编码处理、敏感字符处理等.</p><h2 id="基本使用操作">1.1. 基本使用操作</h2><ul><li>第1步,定义过滤器:定义一个类,实现 Filter 接口,并重写其所有方法.</li><li>第2步,配置过滤器:Filter类上加 @WebFilter 注解,配置拦截资源的路径.引导类上加 @ServletComponentScan 开启Servlet组件支持.</li></ul><h3 id="定义过滤器">1.1.1. 定义过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">//初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截到请求时,调用该方法,可以调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁方法, web服务器关闭时调用, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置过滤器">1.1.2. 配置过滤器</h3><p>Filter的配置需要在Filter类上添加一个注解：@WebFilter,并指定属性urlPatterns,通过这个属性指定过滤器要拦截哪些请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">//初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截到请求时,调用该方法,可以调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁方法, web服务器关闭时调用, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Filter类上面加了@WebFilter注解之后,接下来我们还需要在启动类上面加上一个注解@ServletComponentScan,通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//开启对Servlet组件的支持</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TliasManagementApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TliasManagementApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登录校验">1.2. 登录校验</h2><ol><li>获取请求url</li><li>判断请求url中是否包含login,如果包含,说明是登录操作,放行</li><li>获取请求头中的令牌（token）</li><li>判断令牌是否存在,如果不存在,响应 401</li><li>解析token,如果解析失败,响应 401</li><li>放行<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA%E6%8A%80%E6%9C%AF/filter%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png" alt="Filter登录校验流程"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 令牌校验过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) resp;</span><br><span class="line">        <span class="comment">//1. 获取请求url。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行。</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123; <span class="comment">//登录请求</span></span><br><span class="line">            log.info(<span class="string">&quot;登录请求 , 直接放行&quot;</span>);</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取请求头中的令牌（token）。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123; <span class="comment">//jwt为空</span></span><br><span class="line">            log.info(<span class="string">&quot;获取到jwt令牌为空, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 解析token，如果解析失败，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;解析令牌失败, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 放行。</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法, 放行&quot;</span>);</span><br><span class="line">        chain.doFilter(request , response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行流程">1.3. 执行流程</h2><p>单个Filter会再初始化执行init(),放行执行doFilter(),销毁执行destroy()<br>多个Filter按照过滤器类名（字符串）的自然排序执行<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA%E6%8A%80%E6%9C%AF/filter.png" alt="Filter执行流程"></p><h1 id="Interceptor拦截器">2. Interceptor拦截器</h1><p>拦截器是一种动态拦截方法调用的机制,类似于过滤器,是Spring框架中提供的,用来动态拦截控制器方法的执行</p><h2 id="基本使用操作-1">2.1. 基本使用操作</h2><ul><li><ol><li>定义拦截器</li></ol></li><li><ol start="2"><li>注册配置拦截器</li></ol></li></ul><h3 id="定义拦截器">2.1.1. 定义拦截器</h3><p>实现HandlerInterceptor接口,并重写其所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//目标资源方法执行前执行。 返回true：放行    返回false：不放行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册配置拦截器">2.1.2. 注册配置拦截器</h3><p>创建一个配置类 WebConfig,实现WebMvcConfigurer接口,并重写addInterceptors方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoInterceptor demoInterceptor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(demoInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登录校验-1">2.2. 登录校验</h2><p>和登录校验Filter过滤器当中的逻辑完全一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 获取请求url。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行。</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123; <span class="comment">//登录请求</span></span><br><span class="line">            log.info(<span class="string">&quot;登录请求 , 直接放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取请求头中的令牌（token）。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123; <span class="comment">//jwt为空</span></span><br><span class="line">            log.info(<span class="string">&quot;获取到jwt令牌为空, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 解析token，如果解析失败，返回错误结果（未登录）。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;解析令牌失败, 返回错误结果&quot;</span>);</span><br><span class="line">            response.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 放行。</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法, 放行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenInterceptor tokenInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(tokenInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器的使用细节">2.3. 拦截器的使用细节</h2><ul><li>拦截器的拦截路径配置</li><li>拦截器的执行流程</li></ul><h3 id="2-5-4-拦截路径">2.3.1. 2.5.4 拦截路径</h3><p>通过addPathPatterns(“要拦截路径”)方法,就可以指定要拦截哪些资源.<br>还可以指定不拦截哪些资源,只需要调用excludePathPatterns(“不拦截路径”)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoInterceptor demoInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(demoInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);<span class="comment">//设置不拦截的请求路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><h3 id="执行流程-1">2.3.2. 执行流程</h3><p>定义了拦截器后,会在执行Controller的方法之前,请求被拦截器拦截住.执行preHandle()方法,这个方法执行完成后需要返回一个布尔类型的值,如果返回true,就表示放行本次操作,才会继续访问controller中的方法;如果返回false,则不会放行(controller中的方法也不会执行).<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA%E6%8A%80%E6%9C%AF/inter.png" alt="执行流程"></p><h1 id="过滤器和拦截器之间的区别">3. 过滤器和拦截器之间的区别</h1><ul><li>接口规范不同:过滤器需要实现Filter接口,而拦截器需要实现HandlerInterceptor接口.</li><li>拦截范围不同:过滤器Filter会拦截所有的资源,而Interceptor只会拦截Spring环境中的资源.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;统一拦截技术有两种,Filter过滤器和Interceptor拦截器,用于统一拦截到所有的请求校验令牌的有效性.两种只需要实现一种即可.&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Web登录校验之会话技术</title>
    <link href="http://example.com/2025/07/17/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2025/07/17/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</id>
    <published>2025-07-17T11:59:48.000Z</published>
    <updated>2025-07-17T13:17:29.214Z</updated>
    
    <content type="html"><![CDATA[<p>登录校验,指的是我们在服务器端接收到浏览器发送过来的请求之后,首先我们要对请求进行校验.先要校验一下用户登录了没有,如果用户已经登录了,就直接执行对应的业务操作就可以了;如果用户没有登录,此时就不允许他执行相关的业务操作,直接给前端响应一个错误的结果,最终跳转到登录页面,要求他登录成功之后,再来访问对应的数据.<br>主要涉及两个技术,会话技术与统一拦截技术.<br>本文介绍会话技术.</p><span id="more"></span><h1 id="会话技术">1. 会话技术</h1><p>用户打开浏览器就会 建立会话,直到断开连接前产生的多次请求和响应都是在这一次会话中.如果开了多个浏览器就是产生多个会话.</p><h1 id="会话跟踪技术">2. 会话跟踪技术</h1><p>为了维护浏览器状态,需要使用会话跟踪技术维护浏览器的状态,以便在同一次会话的多次请求间共享数据.</p><h2 id="Cookie">2.1. Cookie</h2><p>cookie是客户端会话跟踪技术,它是存储在客户端浏览器的,我们可以在浏览器第一次发起请求来请求服务器的时候,在服务器端设置一个cookie来存储当前登录用户的用户名及ID.然后服务器响应数据会自动的带上cookie并存储到浏览器本地,此后的每一次请求中,客户端都会把该cookie一同携带到服务端.<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/cookie.png" alt="cookie流程"></p><ul><li>优点：HTTP协议中支持的技术(像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带,都是浏览器自动进行的,是无需我们手动操作的)</li><li>缺点：<ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全,用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><h2 id="Session">2.2. Session</h2><p>session是服务器端会话跟踪技术,存储在服务器端的.而Session的底层其实就是基于Cookie 来实现.<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/session.png" alt="Session流程"></p><ul><li>优点：Session是存储在服务端的,安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域<br>Session 底层是基于Cookie实现的会话跟踪,如果Cookie不可用,则该方案,也就失效了.</li></ul></li></ul><h2 id="Token-Jwt令牌">2.3. Token(Jwt令牌)</h2><p>如果通过令牌技术来跟踪会话,我们就可以在浏览器发起请求.在请求登录接口的时候,如果登录成功,就可以生成一个令牌,令牌就是用户的合法身份凭证.接下来在响应数据的时候,就可以直接将令牌响应给前端.<br>接下来我们在前端程序当中接收到令牌之后,就需要将这个令牌存储起来.这个存储可以存储在 cookie 当中,也可以存储在其他的存储空间(比如：localStorage)当中.<br>接下来,在后续的每一次请求当中,都需要将令牌携带到服务端.携带到服务端之后,接下来我们就需要来校验令牌的有效性.如果令牌是有效的,就说明用户已经执行了登录操作,如果令牌是无效的,就说明用户之前并未执行登录操作.<br>此时,如果是在同一次会话的多次请求之间,我们想共享数据,我们就可以将共享的数据存储在令牌当中就可以了.<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/token.png" alt="Token流程"></p><ul><li>优点：<ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器的存储压力(无需在服务器端存储)</li></ul></li><li>缺点：需要自己实现(包括令牌的生成、令牌的传递、令牌的校验)</li></ul><h1 id="Jwt令牌">3. Jwt令牌</h1><p>前面介绍三种会话跟踪技术,上面两种传统的会话技术,在现在的企业开发当中存在很多的问题.为了解决这些问题,在现在的企业开发当中,基本上都会采用第三种方案Jwt令牌技术.</p><h2 id="Jwt的组成">3.1. Jwt的组成</h2><p>JWT的组成： (JWT令牌由三个部分组成,三个部分之间使用英文的点来分割)</p><ul><li>第一部分:Header(头), 记录令牌类型、签名算法等. 例如：{“alg”:”HS256”,”type”:”JWT”}</li><li>第二部分:Payload(有效载荷),携带一些自定义信息、默认信息等. 例如：{“id”:”1”,”username”:”Tom”}</li><li>第三部分:Signature(签名),防止Token被篡改、确保安全性.将header、payload,并加入指定秘钥,通过指定签名算法计算而来.<br><img src="/Web%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E4%B9%8B%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/jwt%E7%BB%84%E6%88%90.png" alt="Jwt组成"></li></ul><h2 id="Jwt编码原理">3.2. Jwt编码原理</h2><ul><li>对JSON格式的数据进行一次base64编码.</li><li>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式.既然能编码,那也就意味着也能解码.所使用的64个字符分别是A到Z、a到z、 0- 9,一个加号,一个斜杠,加起来就是64个字符.任何数据经过base64编码之后,最终就会通过这64个字符来表示.当然还有一个符号,那就是等号.等号它是一个补位的符号.</li><li>需要注意的是Base64是编码方式,而不是加密方式.</li></ul><h2 id="Jwt-Maven依赖">3.3. Jwt Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Jwt生成代码实现">3.4. Jwt生成代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenJwt</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">&quot;id&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    claims.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;itheima&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder().signWith(SignatureAlgorithm.HS256, <span class="string">&quot;aXRjYXN0&quot;</span>)</span><br><span class="line">        .addClaims(claims)</span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">12</span> * <span class="number">3600</span> * <span class="number">1000</span>))</span><br><span class="line">        .compact();</span><br><span class="line"></span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jwt校验代码实现">3.5. Jwt校验代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testParseJwt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser().setSigningKey(<span class="string">&quot;aXRjYXN0&quot;</span>)</span><br><span class="line">        .parseClaimsJws(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAsInVzZXJuYW1lIjoiaXRoZWltYSIsImV4cCI6MTcwMTkwOTAxNX0.N-MD6DmoeIIY5lB5z73UFLN9u7veppx1K5_N_jS9Yko&quot;</span>)</span><br><span class="line">        .getBody();</span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;登录校验,指的是我们在服务器端接收到浏览器发送过来的请求之后,首先我们要对请求进行校验.先要校验一下用户登录了没有,如果用户已经登录了,就直接执行对应的业务操作就可以了;如果用户没有登录,此时就不允许他执行相关的业务操作,直接给前端响应一个错误的结果,最终跳转到登录页面,要求他登录成功之后,再来访问对应的数据.&lt;br&gt;主要涉及两个技术,会话技术与统一拦截技术.&lt;br&gt;本文介绍会话技术.&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Idea的Bug</title>
    <link href="http://example.com/2025/07/14/IntellijIdea%E7%9A%84Bug/"/>
    <id>http://example.com/2025/07/14/IntellijIdea%E7%9A%84Bug/</id>
    <published>2025-07-14T00:44:13.000Z</published>
    <updated>2025-07-17T11:58:53.016Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录Intellij Idea的一些Bug和部分解决措施.</p><span id="more"></span><h1 id="Directory-‘…-ProjectNamePath-…’-does-not-contain-a-Gradle-build">1. Directory ‘…&#x2F;ProjectNamePath&#x2F;…’ does not contain a Gradle build.</h1><h2 id="问题出现的部分原因">1.1. 问题出现的部分原因</h2><p>1.在创建product模块时,作为gradle项目创建,后来改成maven项目,但IDEA认为该模块是Gradle项目,在尝试编译时寻找Gradle配置文件.<br>2.之前创建的项目直接将文件夹删除了,并没有清除记录</p><h2 id="解决方法">1.2. 解决方法</h2><p>找到对应项目目录下的gradle.xml文件,一般在’…&#x2F;ProjectNamePath&#x2F;.idea&#x2F;gradle.xml’.将其中涉及项目的<option name="...">都注释掉.</option></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录Intellij Idea的一些Bug和部分解决措施.&lt;/p&gt;</summary>
    
    
    
    <category term="Bug" scheme="http://example.com/categories/Bug/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb的Bug之MyBatis</title>
    <link href="http://example.com/2025/07/09/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/"/>
    <id>http://example.com/2025/07/09/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/</id>
    <published>2025-07-09T09:02:20.000Z</published>
    <updated>2025-07-14T07:54:25.747Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录MyBatis的一些Bug和部分解决措施.</p><span id="more"></span><h1 id="Expected-one-result-or-null-to-be-returned-by-selectOne-but-found-2">1. Expected one result (or null) to be returned by selectOne(), but found: 2</h1><h2 id="问题描述">1.1. 问题描述</h2><p>在使用MyBatis的<code>selectOne()</code>方法时,期望返回一个结果或null,但实际上返回了两个结果,导致抛出异常.<br><img src="/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A3%85%E4%B8%8D%E4%B8%8B%E6%95%B0%E6%8D%AE.png" alt="返回值装不下数据"></p><h2 id="解决方法">1.2. 解决方法</h2><p>实际上是方法返回了多条数据,并没有用集合等对象去存储.只要把方法逻辑改为将查询结果存储到List等集合中即可.</p><h1 id="BindException-Invalid-bound-statement-not-found-xxx">2. BindException: Invalid bound statement (not found): xxx</h1><h2 id="问题描述-1">2.1. 问题描述</h2><p>没有找到与xxx匹配的SQL语句<br><img src="/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/%E6%9C%AA%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94SQL.png" alt="没有找到与xxx匹配的SQL语句"></p><h2 id="解决方法-1">2.2. 解决方法</h2><p>这是基于Xml文件注入SQL语句才会产生的问题,需注意是否写与mapper中的方法同名的Xml文件.</p><h1 id="Error-parsing-Mapper-XML-The-Xml-location-is-‘…-xxx-xml’-Cause-org-apache-ibatis-builder-BuilderException-Wrong-namespace-Excepted-‘aMapper’-but-found-‘bMapper’">3. Error parsing Mapper XML. The Xml location is ‘…&#x2F;xxx&#x2F;xml’. Cause: org.apache.ibatis.builder.BuilderException: Wrong namespace. Excepted ‘aMapper’, but found ‘bMapper’</h1><h2 id="问题描述-2">3.1. 问题描述</h2><p>Mapper XML文件的namespace与Mapper接口不匹配.<br><img src="/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%94%99%E8%AF%AF.png" alt="Mapper XML文件的namespace与Mapper接口不匹配"></p><h2 id="解决方法-2">3.2. 解决方法</h2><p>检查Mapper XML文件的namespace是否与Mapper接口的名称一致,有可能是没写全类名,也就是要把包名也写全.</p><h1 id="ExecutorException-A-query-was-run-and-no-Result-Maps-were-found-for-the-Mapped-Statement-‘xxx’-It’s-likely-that-neither-a-Result-Type-nor-a-Result-Map-was-specified">4. ExecutorException: A query was run and no Result Maps were found for the Mapped Statement ‘xxx’. It’s likely that neither a Result Type nor a Result Map was specified.</h1><h2 id="问题描述-3">4.1. 问题描述</h2><p>Mapper XML文件中没有配置Result Type或Result Map.<br><img src="/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/%E6%9F%A5%E8%AF%A2%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="Mapper XML文件中没有配置Result Type或Result Map"></p><h2 id="解决方法-3">4.2. 解决方法</h2><p>执行查询语句一定要有返回值去接收查询结果,所以检查Mapper XML文件,确保配置Result Type或Result Map.</p><h1 id="SQLSyntaxErrorException-You-have-an-error-in-your-SQL-syntax-check-the-manual-that-corresponds-to-your-MySQL-server-version-for-the-right-syntax-to-use-near-‘xxx’-at-line-1">5. SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘xxx’ at line 1</h1><h2 id="问题描述-4">5.1. 问题描述</h2><p>SQL语句语法错误.<br><img src="/JavaWeb%E7%9A%84Bug%E4%B9%8BMyBatis/SQL%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF.png" alt="SQL语句语法错误"></p><h2 id="解决方法-4">5.2. 解决方法</h2><p>检查SQL语句,确保语法正确.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录MyBatis的一些Bug和部分解决措施.&lt;/p&gt;</summary>
    
    
    
    <category term="Bug" scheme="http://example.com/categories/Bug/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis的入门</title>
    <link href="http://example.com/2025/07/09/MyBatis%E7%9A%84%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2025/07/09/MyBatis%E7%9A%84%E5%85%A5%E9%97%A8/</id>
    <published>2025-07-09T03:23:20.000Z</published>
    <updated>2025-07-09T09:10:12.387Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis是一款优秀的持久层框架,用于简化JDBC的开发.<br>本文及后续JavaWeb所创建的项目均为Maven+SpringBoot项目,用的是Aliyun的Maven仓库.<br>主要记录MyBatis依赖的安装过程和入门操作.</p><span id="more"></span><h1 id="MyBatis的安装">1. MyBatis的安装</h1><h2 id="导入MyBatis依赖和MySQL驱动">1.1. 导入MyBatis依赖和MySQL驱动</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目结构">1.2. 项目结构</h2><p>项目结构如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MyBatisDemo</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── com</span><br><span class="line">│   │   │       └── example</span><br><span class="line">│   │   │           └── mybatisdemo</span><br><span class="line">│   │   │               ├── domain</span><br><span class="line">│   │   │               │    └── pojo</span><br><span class="line">│   │   │               │         └──User.java</span><br><span class="line">│   │   │               ├── mapper</span><br><span class="line">│   │   │               │   └── UserMapper.java</span><br><span class="line">│   │   │               └── MyBatisDemoApplication.java</span><br><span class="line">│   │   ├── test</span><br><span class="line">│   │   │   └── java</span><br><span class="line">│   │   │       └── com</span><br><span class="line">│   │   │           └── example</span><br><span class="line">│   │   │               └── mybatisdemo</span><br><span class="line">│   │   │                   └── MyBatisDemoApplicationTests.java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   │       └── application.properties</span><br></pre></td></tr></table></figure><h2 id="项目配置">1.3. 项目配置</h2><p>在application.properties中配置数据库连接信息.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据库访问的url地址</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/databaseName</span></span><br><span class="line"><span class="comment">#数据库驱动类类名</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#访问数据库-用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#访问数据库-密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">pass</span></span><br></pre></td></tr></table></figure><h1 id="MyBatis的初编码">2. MyBatis的初编码</h1><h2 id="编写Mapper接口">2.1. 编写Mapper接口</h2><p>在src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;mybatisdemo&#x2F;mapper目录下创建UserMapper.<br>持久层接口定义SQL语句.<br>java文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user (username, password) values (#&#123;username&#125;, #&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set username = #&#123;username&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(String username, String password, <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单元测试">2.2. 单元测试</h2><p>在src&#x2F;test&#x2F;java&#x2F;com&#x2F;example&#x2F;mybatisdemo&#x2F;MyBatisDemoApplicationTests.java中编写单元测试.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBatisDemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser(user);</span><br><span class="line">        assertEquals(<span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateUser(<span class="string">&quot;test2&quot;</span>, <span class="string">&quot;1234567&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        assertEquals(<span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDeleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteUser(<span class="number">1</span>);</span><br><span class="line">        assertEquals(<span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用逻辑">2.3. 调用逻辑</h2><p>MyBatis的调用逻辑是通过Mapper接口与数据库进行交互的.在Spring Boot中,MyBatis会自动扫描Mapper接口并生成代理对象.<br><img src="/MyBatis%E7%9A%84%E5%85%A5%E9%97%A8/%E8%B0%83%E7%94%A8%E9%80%BB%E8%BE%91.png" alt="调用逻辑"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis是一款优秀的持久层框架,用于简化JDBC的开发.&lt;br&gt;本文及后续JavaWeb所创建的项目均为Maven+SpringBoot项目,用的是Aliyun的Maven仓库.&lt;br&gt;主要记录MyBatis依赖的安装过程和入门操作.&lt;/p&gt;</summary>
    
    
    
    <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2025/07/08/hello-world/"/>
    <id>http://example.com/2025/07/08/hello-world/</id>
    <published>2025-07-08T11:54:02.612Z</published>
    <updated>2025-07-14T08:12:11.638Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客,我还在学习java中,目前主要发布java学习中的部分笔记和排错记录.<br>同时也会分享一些Python,C++等语言编写的好玩的项目.</p><span id="more"></span><h1 id="今后写博客要求的规范记录在下">1. 今后写博客要求的规范记录在下</h1><ol><li>凡是涉及图片包含代码逻辑的,一定用文字把逻辑表达清楚,防止图床失效.</li><li>如果是转载的内容,需要在开头注明转载,并注明作者及出处.</li><li>待补充</li></ol><h1 id="目前的博客使用的Hexo搭建">2. 目前的博客使用的Hexo搭建</h1><p>Hexo是一个快速、简洁且高效的博客框架，基于Node.js构建，支持Markdown语法</p><h1 id="Hexo搭建过程中需注意的问题">3. Hexo搭建过程中需注意的问题</h1><p>编写博客章节的markdown文档一定不要用markdown编辑器,最好用vsCode或者文本编辑器,不然Hexo无法生成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;欢迎来到我的博客,我还在学习java中,目前主要发布java学习中的部分笔记和排错记录.&lt;br&gt;同时也会分享一些Python,C++等语言编写的好玩的项目.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
